{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Standarisasi Berikut ini adalah standarisasi untuk pengerjaan proyek-proyek yang ada di unit bisnis Algo Network baik itu Braincore, Megalogic, dan Bizzagi. Standarisasi ini dibuat agar semua orang yang ada di dalamnya bisa mempelajarinya dan berbicara dalam bahasa/library/framework/tools yang sama, sehingga ketika ada proyek yang membutuhkan orang-orang dari divisi atau unit bisnis yang berbeda (cross-division project), tantangan dalam adaptasinya tidak terlalu besar Introduction to Algo Network Data Analyst and Business Intelligence Internet of Things (IoT) AI/ML Modelling AI/ML Deployment Frontend Backend Mobile QA Manual QA Automation Database Deployment Blockchain RnD UI/UX Design Graphic Design Project Management SEO Tools","title":"Home"},{"location":"#standarisasi","text":"Berikut ini adalah standarisasi untuk pengerjaan proyek-proyek yang ada di unit bisnis Algo Network baik itu Braincore, Megalogic, dan Bizzagi. Standarisasi ini dibuat agar semua orang yang ada di dalamnya bisa mempelajarinya dan berbicara dalam bahasa/library/framework/tools yang sama, sehingga ketika ada proyek yang membutuhkan orang-orang dari divisi atau unit bisnis yang berbeda (cross-division project), tantangan dalam adaptasinya tidak terlalu besar Introduction to Algo Network Data Analyst and Business Intelligence Internet of Things (IoT) AI/ML Modelling AI/ML Deployment Frontend Backend Mobile QA Manual QA Automation Database Deployment Blockchain RnD UI/UX Design Graphic Design Project Management SEO Tools","title":"Standarisasi"},{"location":"01_introduction_to_algo_network/","text":"Introduction to Algo Network Algo Network adalah sebuah perusahaan holding group di bawah nama PT. Algonacci Sobat Nusantara, yang sampai tulisan ini dibuat, memiliki 3 unit bisnis, yaitu Braincore , Megalogic , dan Bizzagi . Tulisan di bawah ini akan menjelaskan tentang masing-masing bisnis unit, dan bagaimana cara kerja di Algo Network Braincore Braincore adalah sebuah perusahaan yang bergerak di bidang hi-tech , utamanya di bidang AI/ML. Ada beberapa bidang yang digarap, meliputi: AI (termasuk di dalamnya Data Science dan Machine Learning) Internet of Things atau IoT Network Engineering Blockchain Cyber Security Braincore memiliki beberapa proker, yakni Projects Consultant Research paper Open source projects Products Services Blog posting Content creation Training of Trainer (ToT) Curriculum development In-house training Bootcamp Mentorship Webinar Marketing Private dataset Lomba Megalogic Megalogic adalah sebuah software house biasa pada umumnya, adapun bidang yang dikerjakan adalah: Frontend Backend Mobile Quality assurance Bizzagi Bizzagi adalah sebuah digital marketing agency yang mengurus upaya pemasaran (marketing) dari segala unit bisnis yang ada di Algo Network, termasuk Braincore dan juga Megalogic. Namun Bizzagi juga memiliki model bisnisnya sendiri untuk survive, berikut diantaranya: SEO audit and technical SEO Graphic designs UI/UX designs Market research Social media marketing and management Marketplace optimization Ads management Copywriting Email marketing Digital campaign Project management KOL specialist Video editing Motion graphics Brand identity Communication channel Ada 2 kanal komunikasi yang utama di Algo Network dan unit bisnisnya, yaitu adalah menggunakan WhatsApp dan Discord Silahkan contact ke Eric atau Lead Divisinya untuk bergabung ke grup WhatsApp dan juga server Discord Sprint grooming Di Algo Network dan semua unit bisnisnya, menganut sistem Sprint yang merupakan turunan dari sistem Agile dan metodologi dari Scrum. Sprint digunakan untuk mendeskripsikan satu siklus pengembangan yang terbatas waktu. Sprint biasanya berlangsung selama 1 minggu atau 5 hari kerja dari Senin sampai Jumat, dengan tujuan untuk menghasilkan produk, fitur, atau hasil pekerjaan yang dapat dioperasikan dan siap untuk diluncurkan atau tahapan pengembangan selanjutnya. Di dalam 1 sprint ini ada terjadi beberapa event: Task Delegation: Proses pemberian tugas dari Eric ke masing-masing Lead Divisi Task Break Down: Proses break-down atau perincian tugas dari masing-masing Lead Divisi untuk setiap anggota timnya Sprint Grooming: Proses memposting task apa saja yang akan dikerjakan selama 1 sprint itu Development: Proses pengerjaan dan pengembangan selama 1 sprint (5 hari kerja) Weekly Report: Proses pelaporan di akhir minggu, apa saja yang sudah dan belum selesai Daily standup Merupakan meeting yang diadakan setiap harinya untuk mengontrol proses pengerjaan dan pengembangan, melakukan daily report, terjadi di sore hari jam 5 Mandatory meetings Ada beberapa meeting penting di dalam Algo Network: Monthly sync Town hall Training of Trainer Meeting divisi Kembali ke Home","title":"Introduction to Algo Network"},{"location":"01_introduction_to_algo_network/#introduction-to-algo-network","text":"Algo Network adalah sebuah perusahaan holding group di bawah nama PT. Algonacci Sobat Nusantara, yang sampai tulisan ini dibuat, memiliki 3 unit bisnis, yaitu Braincore , Megalogic , dan Bizzagi . Tulisan di bawah ini akan menjelaskan tentang masing-masing bisnis unit, dan bagaimana cara kerja di Algo Network","title":"Introduction to Algo Network"},{"location":"01_introduction_to_algo_network/#braincore","text":"Braincore adalah sebuah perusahaan yang bergerak di bidang hi-tech , utamanya di bidang AI/ML. Ada beberapa bidang yang digarap, meliputi: AI (termasuk di dalamnya Data Science dan Machine Learning) Internet of Things atau IoT Network Engineering Blockchain Cyber Security Braincore memiliki beberapa proker, yakni Projects Consultant Research paper Open source projects Products Services Blog posting Content creation Training of Trainer (ToT) Curriculum development In-house training Bootcamp Mentorship Webinar Marketing Private dataset Lomba","title":"Braincore"},{"location":"01_introduction_to_algo_network/#megalogic","text":"Megalogic adalah sebuah software house biasa pada umumnya, adapun bidang yang dikerjakan adalah: Frontend Backend Mobile Quality assurance","title":"Megalogic"},{"location":"01_introduction_to_algo_network/#bizzagi","text":"Bizzagi adalah sebuah digital marketing agency yang mengurus upaya pemasaran (marketing) dari segala unit bisnis yang ada di Algo Network, termasuk Braincore dan juga Megalogic. Namun Bizzagi juga memiliki model bisnisnya sendiri untuk survive, berikut diantaranya: SEO audit and technical SEO Graphic designs UI/UX designs Market research Social media marketing and management Marketplace optimization Ads management Copywriting Email marketing Digital campaign Project management KOL specialist Video editing Motion graphics Brand identity","title":"Bizzagi"},{"location":"01_introduction_to_algo_network/#communication-channel","text":"Ada 2 kanal komunikasi yang utama di Algo Network dan unit bisnisnya, yaitu adalah menggunakan WhatsApp dan Discord Silahkan contact ke Eric atau Lead Divisinya untuk bergabung ke grup WhatsApp dan juga server Discord","title":"Communication channel"},{"location":"01_introduction_to_algo_network/#sprint-grooming","text":"Di Algo Network dan semua unit bisnisnya, menganut sistem Sprint yang merupakan turunan dari sistem Agile dan metodologi dari Scrum. Sprint digunakan untuk mendeskripsikan satu siklus pengembangan yang terbatas waktu. Sprint biasanya berlangsung selama 1 minggu atau 5 hari kerja dari Senin sampai Jumat, dengan tujuan untuk menghasilkan produk, fitur, atau hasil pekerjaan yang dapat dioperasikan dan siap untuk diluncurkan atau tahapan pengembangan selanjutnya. Di dalam 1 sprint ini ada terjadi beberapa event: Task Delegation: Proses pemberian tugas dari Eric ke masing-masing Lead Divisi Task Break Down: Proses break-down atau perincian tugas dari masing-masing Lead Divisi untuk setiap anggota timnya Sprint Grooming: Proses memposting task apa saja yang akan dikerjakan selama 1 sprint itu Development: Proses pengerjaan dan pengembangan selama 1 sprint (5 hari kerja) Weekly Report: Proses pelaporan di akhir minggu, apa saja yang sudah dan belum selesai","title":"Sprint grooming"},{"location":"01_introduction_to_algo_network/#daily-standup","text":"Merupakan meeting yang diadakan setiap harinya untuk mengontrol proses pengerjaan dan pengembangan, melakukan daily report, terjadi di sore hari jam 5","title":"Daily standup"},{"location":"01_introduction_to_algo_network/#mandatory-meetings","text":"Ada beberapa meeting penting di dalam Algo Network: Monthly sync Town hall Training of Trainer Meeting divisi Kembali ke Home","title":"Mandatory meetings"},{"location":"02_data_analyst_business_intelligence/","text":"Data Analyst & Business Intelligence Tableau over Looker Studio Google Spreadsheet over Excel Python over R MySQL & PostgreSQL Kembali ke Home","title":"Data Analyst & Business Intelligence"},{"location":"02_data_analyst_business_intelligence/#data-analyst-business-intelligence","text":"Tableau over Looker Studio Google Spreadsheet over Excel Python over R MySQL & PostgreSQL Kembali ke Home","title":"Data Analyst &amp; Business Intelligence"},{"location":"03_iot/","text":"Internet of Things (IoT) ESP32 or STM32 as master Arduino, ESP8266, Raspberry, and Jetson as slave Kembali ke Home","title":"Internet of Things (IoT)"},{"location":"03_iot/#internet-of-things-iot","text":"ESP32 or STM32 as master Arduino, ESP8266, Raspberry, and Jetson as slave Kembali ke Home","title":"Internet of Things (IoT)"},{"location":"04_ai_ml_modelling/","text":"AI/ML Modelling ML Classifiers LazyPredict Deep Learning framework TensorFlow PyTorch Image classification Teachable machine Vision Transformers (ViT) from HuggingFace models Object detection YOLOv8 Sentiment analysis BERT-based model LLM OpenAI API Kembali ke Home","title":"AI/ML Modelling"},{"location":"04_ai_ml_modelling/#aiml-modelling","text":"","title":"AI/ML Modelling"},{"location":"04_ai_ml_modelling/#ml-classifiers","text":"LazyPredict","title":"ML Classifiers"},{"location":"04_ai_ml_modelling/#deep-learning-framework","text":"TensorFlow PyTorch","title":"Deep Learning framework"},{"location":"04_ai_ml_modelling/#image-classification","text":"Teachable machine Vision Transformers (ViT) from HuggingFace models","title":"Image classification"},{"location":"04_ai_ml_modelling/#object-detection","text":"YOLOv8","title":"Object detection"},{"location":"04_ai_ml_modelling/#sentiment-analysis","text":"BERT-based model","title":"Sentiment analysis"},{"location":"04_ai_ml_modelling/#llm","text":"OpenAI API Kembali ke Home","title":"LLM"},{"location":"05_ai_ml_deployment/","text":"AI/ML Deployment Untuk proses deployment model AI/ML, mari kita berfokus ke 3 tools ini saja Flask: Sebuah mini framework untuk webserver dengan menggunakan bahasa Python FastAPI: Mirip dengan Flask, namun dilengkapi dengan async keyword dan type hinting -nya Python Streamlit: Sebuah framework untuk deployment cepat karena memiliki banyak sekali komponen yang bisa dipanggil melalui fungsi Python Flask Dalam konteks deployment model AI/ML, kita bisa lakukan 2 pendekatan ini di Flask Web Monolitik API Web Monolitik artinya kita mendeploy model dalam satu aplikasi Flask yang menyediakan UI tampilan web dalam 1 direktori proyek yang sama Sedangkan API adalah kita hanya mendeploy model dan menjalankannya sebagai API, dalam hal ini, konteksnya adalah kita mereturn JSON Flask Web Monolitik Flask umumnya bisa digunakan untuk membuat sebuah backend sederhana seperti framework atau bahasa pemrograman lainnya, kata kuncinya dalah return jenis render_template() Simak materinya disini Mari gunakan virtual environment, pastikan sudah membuat dan masuk ke 1 folder proyek terlebih dahulu $ python -m venv .venv $ (Windows) .venv\\Scripts\\activate $ (UNIX/Linux) source .venv/bin/activate $ pip install flask gunicorn scikit-learn $ pip freeze > requirements.txt Gunakan text editor kesayangan kamu, dan buat file app.py , kita buat aplikasi web monolitik sederhana dengan menggunakan Flask from flask import Flask app = Flask(__name__) @app.route(\"/\") def index(): return \"Hello World!\" if __name__ == \"__main__\": app.run() Kembali ke terminal, jalankan flask run , dan buka di browser alamat localhost di 127.0.0.1:5000 (port default Flask berada di 5000) dan kamu akan mendapatkan tulisan Hello World! Flask API Flask bisa juga digunakan sebagai API untuk mendeploy model AI/ML, kunci utamanya adalah di jenis return jsonify() Simak materinya disini Ada aturan untuk mereturn JSON di berbagai bahasa, bentuknya harus seperti ini \"status\": { \"code\": 200, \"message\": \"Success fetching the API\", }, \"data\": None Struktur Folder Flask Ketika mendeploy model AI/ML untuk skala production, coba gunakan Flask Blueprint untuk modularisasi agar memudahkan ketika pengembangan Contoh Versi Web Monolitik (COMING SOON) Contoh Versi API Kembali ke Home","title":"AI/ML Deployment"},{"location":"05_ai_ml_deployment/#aiml-deployment","text":"Untuk proses deployment model AI/ML, mari kita berfokus ke 3 tools ini saja Flask: Sebuah mini framework untuk webserver dengan menggunakan bahasa Python FastAPI: Mirip dengan Flask, namun dilengkapi dengan async keyword dan type hinting -nya Python Streamlit: Sebuah framework untuk deployment cepat karena memiliki banyak sekali komponen yang bisa dipanggil melalui fungsi Python","title":"AI/ML Deployment"},{"location":"05_ai_ml_deployment/#flask","text":"Dalam konteks deployment model AI/ML, kita bisa lakukan 2 pendekatan ini di Flask Web Monolitik API Web Monolitik artinya kita mendeploy model dalam satu aplikasi Flask yang menyediakan UI tampilan web dalam 1 direktori proyek yang sama Sedangkan API adalah kita hanya mendeploy model dan menjalankannya sebagai API, dalam hal ini, konteksnya adalah kita mereturn JSON","title":"Flask"},{"location":"05_ai_ml_deployment/#flask-web-monolitik","text":"Flask umumnya bisa digunakan untuk membuat sebuah backend sederhana seperti framework atau bahasa pemrograman lainnya, kata kuncinya dalah return jenis render_template() Simak materinya disini Mari gunakan virtual environment, pastikan sudah membuat dan masuk ke 1 folder proyek terlebih dahulu $ python -m venv .venv $ (Windows) .venv\\Scripts\\activate $ (UNIX/Linux) source .venv/bin/activate $ pip install flask gunicorn scikit-learn $ pip freeze > requirements.txt Gunakan text editor kesayangan kamu, dan buat file app.py , kita buat aplikasi web monolitik sederhana dengan menggunakan Flask from flask import Flask app = Flask(__name__) @app.route(\"/\") def index(): return \"Hello World!\" if __name__ == \"__main__\": app.run() Kembali ke terminal, jalankan flask run , dan buka di browser alamat localhost di 127.0.0.1:5000 (port default Flask berada di 5000) dan kamu akan mendapatkan tulisan Hello World!","title":"Flask Web Monolitik"},{"location":"05_ai_ml_deployment/#flask-api","text":"Flask bisa juga digunakan sebagai API untuk mendeploy model AI/ML, kunci utamanya adalah di jenis return jsonify() Simak materinya disini Ada aturan untuk mereturn JSON di berbagai bahasa, bentuknya harus seperti ini \"status\": { \"code\": 200, \"message\": \"Success fetching the API\", }, \"data\": None","title":"Flask API"},{"location":"05_ai_ml_deployment/#struktur-folder-flask","text":"Ketika mendeploy model AI/ML untuk skala production, coba gunakan Flask Blueprint untuk modularisasi agar memudahkan ketika pengembangan Contoh Versi Web Monolitik (COMING SOON) Contoh Versi API Kembali ke Home","title":"Struktur Folder Flask"},{"location":"06_frontend/","text":"Frontend Vue with Vite Nuxt Alpine.js HTMX jQuery Jinja2 EJS Blade Tailwind UI Bootstrap Kembali ke Home","title":"Frontend"},{"location":"06_frontend/#frontend","text":"Vue with Vite Nuxt Alpine.js HTMX jQuery Jinja2 EJS Blade Tailwind UI Bootstrap Kembali ke Home","title":"Frontend"},{"location":"07_backend/","text":"Backend Flask Express Laravel with Livewire Golang (Very Serious Project, Performance Critical, User Oriented) Flask Untuk Flask bisa contoh ke sini Express Dalam menggunakan Express sebagai backend, ada 2 pendekatan: Web Monolitik API Web Monolitik artinya kita mendeploy backend dalam satu aplikasi Express yang menyediakan UI tampilan web dalam 1 direktori proyek yang sama, dengan menggunakan templating engine bernama EJS (Embedded JavaScript) Sedangkan API adalah kita hanya mendeploy backend dan menjalankannya sebagai API, dalam hal ini, konteksnya adalah kita mereturn JSON . Web Monolitik on progress API Mari kita mulai dengan API, namun sebelum lebih jauh, ada arsitektur yang kita perlu sepakati terlebih dahulu. Pertama mari kita lihat struktur folder dari proyek yang akan dibuat, yaitu sebagai berikut: /app \u251c\u2500\u2500 .github/ \u2502 \u251c\u2500\u2500 workflows/ \u2502 \u251c\u2500\u2500 node.js.yml \u251c\u2500\u2500 db/ \u2502 \u251c\u2500\u2500 connect.js \u251c\u2500\u2500 helpers/ \u2502 \u251c\u2500\u2500 forExample.js \u2502 \u251c\u2500\u2500 hashing.js \u2502 \u251c\u2500\u2500 response.js \u251c\u2500\u2500 middleware/ \u2502 \u251c\u2500\u2500 cache.js \u2502 \u251c\u2500\u2500 isAuthenticated.js \u2502 \u251c\u2500\u2500 rateLimiter.js \u251c\u2500\u2500 models/ \u2502 \u251c\u2500\u2500 models.js \u251c\u2500\u2500 routes/ \u2502 \u251c\u2500\u2500 index/ \u2502 \u251c\u2500\u2500 index.controller.js \u2502 \u251c\u2500\u2500 index.router.js \u2502 \u251c\u2500\u2500 index.test.js /node_modules /.dockerignore /.env /.gitignore /api-docs.yaml /app.js /Dockerfile /LICENSE /package-lock.json /package.json /README.md /server.js Ringkasan Struktur Proyek Bagaimana struktur foldernya hehe, kamu kebingungan? Santuy, mari kita bahas 1 per 1. Jadi struktur folder diatas merupakan struktur folder yang menurut kami cukup baik dan nyaman digunakan untuk kebutuhan pembuatan API menggunakan ExpressJS. Di arsitektur ini kita membuat proyeknya nodeJS nya dengan type 'commonJS' yah, (reminder) jadi saat modularisasi atau pemanggilan file atau librari kita gunakan const ... = require('nama file/librari') , dan untuk mengexport variabel/function/class kita gunakan module.exports = nama variable/function/class . Nah untuk memulai sobat bisa membuatnya secara manual, atau bisa menduplikat template yang sudah kami sediakan ya di repositori github algonacci . Namun, walau sobat bisa langsung menduplikat, usahakan tetap mengerti dengan arsitektur tersebut. Oleh karena itu, yuk simak penjelasan-penjelasan tentang arsitektur tersebut dibawah: Starting Point (server.js) Pertama, jika sobat memulainya secara manual, buatlah sebuah proyek Node.js baru dengan menggunakan command npm init , dengan starting pointnya di server.js , lalu isi dengan code seperti berikut: require(\"dotenv\").config(); const http = require(\"http\"); const app = require(\"./app\"); const PORT = process.env.PORT || 8000; const server = http.createServer(app); const start = async () => { try { server.listen(PORT, () => { console.log(`\ud83d\ude80 [SERVER] is running on port http://localhost:${PORT}`); }); } catch (error) { console.log(error); } }; start(); Pada kode tersebut sobat bisa lihat ada sebuat variabel yang di panggil dari sebuah file, yaitu app. Setelah kita membuat starting point ( server.js ), selanjutnya root folder kita buat lagi 1 file dengan nama app.js . Di file ini kita akan melakukan inisialisasi serta pemanggilan-pemanggilan router agar terlihat rapi. Dengan kode seperti berikut: const express = require(\"express\"); const morgan = require(\"morgan\"); const cors = require(\"cors\"); const app = express(); const swaggerUi = require('swagger-ui-express'); const YAML = require('yamljs') const apiDocs = YAML.load('./api-docs.yaml') //Middleware const { isAuthenticated } = require(\"./middleware/isAuthenticated\"); //Router const indexRouter = require(\"./routes/index/index.router\"); app.use(express.json()); app.use(morgan(\"dev\")); app.use(cors()); //Set API DOCS with Swagger app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(apiDocs)) //Regis Routes app.use(\"/\", isAuthenticated, indexRouter); module.exports = app; Routes/ Hal yang cukup berbeda dari kebanyakan arsitektur nodeJS yang lain dengan arsitektu yang kami buat yaitu, terletak pada folder routes/ ini. Pada folder ini, diisi kan dengan sub folder lagi sesuai kebutuhan/fitur yang ingin dikembangkan, lalu didalam sub folder ini berisikan file .router.js untuk mengatur jalurnya, .controller.js untuk membuat logika programnya, dan .test.js untuk membuat testing dari jalur/feat tersebut. Seperti sobat tahu, biasanya kebanyakan arsitektur nodeJS memisahkan ketiga hal tersebut (router/controller/testing) pada folder folder terpisah. Disini kami menggabungkannya karena memudahkan dalam pengerjaannya baik perorangan maupun team, dimana kita bisa mengerjakannya perfitur, sehingga lebih rapi dan terstruktur. Dalam pembuatana nama folder dan file nya di namakan dengan nama fitur yang kita buat/kembangkan, misal fitur 'index' maka sub folder dari routes/ adalah folder index/ yang berisi 3 file yaitu index.controller.js , index.router.js , dan index.test.js . Berikut adalah contoh kodenya: index.controller.js const { forExample } = require(\"../../helpers/forExample\"); const response = require(\"./../../helpers/response\") const helloIndex = (req, res) => { forExample(); response.res200(\"Success fetching the API!\", null, res) }; const helloPost = (req, res) => { const inputData = req.body; console.log(inputData); if (Object.keys(inputData).length !== 0) { response.res201(\"Success create data\", inputData, res) } else { response.res400(res) } }; const getData = async (req, res) => { try { let result = 'Testing '.repeat(10000) response.resCustom(200, \"Success fetching data\", result, res) } catch (error) { console.log(error.message) response.res500(res) } }; module.exports = { helloIndex, helloPost, getData }; index.router.js const express = require(\"express\"); const router = express.Router(); const compression = require(\"compression\"); //Middleware const cache = require('../../config/cache') const limit = require(\"./../../config/rateLimiter\") //Controller const index = require(\"./index.controller\"); //Routes router.route(\"/\").get(limit(10) ,index.helloIndex); //Set limiter 10 request/minutes router.route(\"/\").post(index.helloPost); router.route(\"/test\").get(compression(), cache('1 minutes'),index.getData); //Set compression and cache module.exports = router; index.test.js const { response } = require(\"express\"); const request = require(\"supertest\"); const app = require(\"../../app\"); const token = 'Ceritanya Token JWT'; describe(\"Test GET /\", () => { test(\"It should respond with 200 success\", async () => { const response = await request(app).get(\"/\") .set(\"Authorization\", `Bearer ${token}`) .expect(\"Content-Type\", /json/); expect(response.status).toBe(200); expect(response.body).toEqual({ status: { code: 200, message: \"Success fetching the API!\", }, data: null, }); }); }); ...dst Middleware/ Folder middleware ini sama seperti arsitektur nodejs lainnya, disini kita menyimpan file-file yang berfungsi sebagai middleware atau file yang berisi fungsi untuk menengahi antara router dan controller. Biasanya berisikan pengecekan atau validasi seperti authentikasi/authorisasi, cache, rate limiter atau yang lainnya. Pada template yang kami buat kami menyediakan middleware yang umum digunakan yakni file isAuthenticate.js . Berikut contoh kodenya: const jwt = require(\"jsonwebtoken\") const response = require(\"./../helpers/response\") const isAuthenticated = (req, res, next) => { const { authorization } = req.headers; if (!authorization) { console.log(\"Token is not exist\") return response.res401(res); } const token = authorization.split(\" \")[1] || authorization; try { // // Uncomment to use Basic verify jwt token // const secret = process.env.JWT_KEY; // const jwtDecode = jwt.verify(token, secret); // //create user data to use in server, adjust with your data when you create token first time // const user = { // id: jwtDecode.id, // email: jwtDecode.email, // name: jwtDecode.name, // role: jwtDecode.role, // token, // }; // req.user = user; //set data to use in the next console.log(\"Anjay Authenticate\") next(); } catch (error) { console.log(error.message); return response.res401(res); } }; module.exports = { isAuthenticated }; Helpers/ Folder helpers/ lebih kurang sama dengan utils/ dimana didalam folder ini disimpan file-file fungsi yang akan sering digunakan. Seperti customisasi response, atau pengecekan data di database, atau yang lainnya. Untuk penamaan filenya disesuaikan dengan fungsi yang dibuat, berikut contoh isi kode dari file isExample.js dari template yang kami sediakan: const forExample = () => { console.log(\"Anjay pake helper\"); }; module.exports = { forExample }; note: untuk file isExample.js tersebut hanya contoh, sobat bisa ubah dan sesuakan penamaan dan isinya sesuai kebutuhan sobat, atau sobat bisa hapus jika tidak diperlukan. Db/ (Database) Jika mendengar API pasti tidak jauh dari yang namanya database, umumnya jika kita membuat sebuah API biasanya pasti melakukan CRUD ke database baik SQL (MYSQL/POSTGREE/dll) atau bahkan NOSQL (MongoDB/Firestore/dll). Sehingga kita pasti perlu melakukan pembuatan koneksi ke database tersebut. Nah, disinilah kita gunakan folder db/ untuk menyimpan file yang mengandung kode untuk melakukan koneksi ke database. Berikut contoh kode file koneksi ke firestore (noSql): var admin = require(\"firebase-admin\"); admin.initializeApp({ credential: admin.credential.cert(JSON.parse(process.env.SERVICEACCOUNTKEY)) }); const db = admin.firestore() module.exports = db Models/ Jika kita melakukan koneksi atau aktifitas CRUD ke database maka kita juga tidak jauh dari yang namanya model. Apa itu model? model merupakan tempat kita membuat sebuah inisialisasi atau mendisign tabel/schema(SQL) di proyek kita. Biasanya saat menerapkan konsep model seperti ini kita menggunakan yang namanya ORM (Object Relation Mapping) misalnya seperti sequelize/prisma/typeorm/lainnya. Nah, di folder models/ ini lah tempat menyimpan file-file model tersebut. .github/Workflows Terakhir ada folder .github/ yang berisi subfolder Workflows/ . Apakah ini? nah, disini merupakan folder tempat kita menyimpan alur kerja atau simplenya file automasi yang berisi kode langkah-langkah pengerjaan saat terjadi komunikasi ke github kita. Misalnya, seperti saat terjadi push/pull/lainnya ke repo github kita apa yang akan kita lakukan. Untuk template yang kami sediakan, kami sudah membuat file automasi untuk melakukan pengecekan semua kode-kode dari file .test.js yang kita buat, guna memastikan semua fitur yang kita buat dan sudah test berjalan dengan benar, baik di local maupun saat setelah di push ke github. Berikut contoh kode dari file automasi node.js.yaml yang kami sediakan di template: name: Express Docker Template Application on: push: branches: [\"main\"] pull_request: branches: [\"main\"] jobs: build: env: CI: true # MONGODB_URI: mongodb://localhost/nasa strategy: matrix: node-version: [14.x, 16.x, 18.x] # See supported Node.js release schedule at https://nodejs.org/en/about/releases/ # mongodb-version: [\"4.4\"] runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v3 with: node-version: ${{ matrix.node-version }} cache: \"npm\" - run: npm install - run: npm test note: Kode di atas melakukan pengecekan terhadap kode kita, di versi nodeJS 14.x, 16.x, dan 18.x API Documentation Jika kita membuat sebuah proyek API, pastinya kita akan membuat sebuah dokumentasi dari API tersebut betul? Nah, untuk membuat sebuah dokumentasi API ada banyak tools yang tersedia, seperti Postman/Swagger/ReDoc/lainnya. Disini kita akan menggunakan swagger sebagai tools untuk membuat dokumentasinya, mengapa agar kita bisa langsung membuatnya di dalam proyek kita, tanpa harus menginstall aplikasi ketiga atau membuat di website toolsnya tersebut. Di root folder proyek kita, sobat bisa lihat di file app.js ada potongan kode seperti berikut: const swaggerUi = require('swagger-ui-express'); const YAML = require('yamljs') const apiDocs = YAML.load('./api-docs.yaml') ... //Set API DOCS with Swagger app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(apiDocs)) ... Yap, seperti potongan kode di atas, jika kita ingin menggunakan swagger langsung di proyek kita, kita perlu menginstall 2 librari yakni, swagger-ui-express dan yaml.js . Disini kita menggunakan swagger-ui-express yang membuatkan otomatis tampilan dokumentasi swaggernya dan yamljs untuk membaca kode dokumentasi yang kita buat menggunakan file .yaml seperti ./api-docs.yaml yang kami siapkan di template. Disini kita harus membuat terlebih dahulu dokumentasinya di file api-docs.yaml serperti contoh: openapi: '3.0.2' info: title: API Documentation description: Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML. version: '1.0.0' servers: - url: \"http://localhost:8080\" description: Optional server description, e.g. Main (development) server components: securitySchemes: bearerAuth: type: http scheme: bearer bearerFormat: JWT security: - bearerAuth: [] paths: /: get: summary: Returns a list of users. description: Optional extended description in CommonMark or HTML. tags: - 'Index' security: - bearerAuth: [] responses: '200': description: Response success for index routes. content: application/json: schema: type: object properties: status: type: object properties: code: type: integer format: int64 example: 200 message: type: string example: \"Success fetching the API!\" data: type: string example: null '401': description: Unauthorized user. default: description: Unexpected error Kemudian kita daftarkan dan aktifkan seperti akhir potongan kode sebelumnya app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(apiDocs)) sobat bisa mengganti path untuk dokumentasinya pada parameter pertama, untuk template yang kami sediakan, kami gunakan /api-docs untuk melihat dokumentasi dari API-nya. Kembali ke Home","title":"Backend"},{"location":"07_backend/#backend","text":"Flask Express Laravel with Livewire Golang (Very Serious Project, Performance Critical, User Oriented)","title":"Backend"},{"location":"07_backend/#flask","text":"Untuk Flask bisa contoh ke sini","title":"Flask"},{"location":"07_backend/#express","text":"Dalam menggunakan Express sebagai backend, ada 2 pendekatan: Web Monolitik API Web Monolitik artinya kita mendeploy backend dalam satu aplikasi Express yang menyediakan UI tampilan web dalam 1 direktori proyek yang sama, dengan menggunakan templating engine bernama EJS (Embedded JavaScript) Sedangkan API adalah kita hanya mendeploy backend dan menjalankannya sebagai API, dalam hal ini, konteksnya adalah kita mereturn JSON .","title":"Express"},{"location":"07_backend/#web-monolitik","text":"on progress","title":"Web Monolitik"},{"location":"07_backend/#api","text":"Mari kita mulai dengan API, namun sebelum lebih jauh, ada arsitektur yang kita perlu sepakati terlebih dahulu. Pertama mari kita lihat struktur folder dari proyek yang akan dibuat, yaitu sebagai berikut: /app \u251c\u2500\u2500 .github/ \u2502 \u251c\u2500\u2500 workflows/ \u2502 \u251c\u2500\u2500 node.js.yml \u251c\u2500\u2500 db/ \u2502 \u251c\u2500\u2500 connect.js \u251c\u2500\u2500 helpers/ \u2502 \u251c\u2500\u2500 forExample.js \u2502 \u251c\u2500\u2500 hashing.js \u2502 \u251c\u2500\u2500 response.js \u251c\u2500\u2500 middleware/ \u2502 \u251c\u2500\u2500 cache.js \u2502 \u251c\u2500\u2500 isAuthenticated.js \u2502 \u251c\u2500\u2500 rateLimiter.js \u251c\u2500\u2500 models/ \u2502 \u251c\u2500\u2500 models.js \u251c\u2500\u2500 routes/ \u2502 \u251c\u2500\u2500 index/ \u2502 \u251c\u2500\u2500 index.controller.js \u2502 \u251c\u2500\u2500 index.router.js \u2502 \u251c\u2500\u2500 index.test.js /node_modules /.dockerignore /.env /.gitignore /api-docs.yaml /app.js /Dockerfile /LICENSE /package-lock.json /package.json /README.md /server.js","title":"API"},{"location":"07_backend/#ringkasan-struktur-proyek","text":"Bagaimana struktur foldernya hehe, kamu kebingungan? Santuy, mari kita bahas 1 per 1. Jadi struktur folder diatas merupakan struktur folder yang menurut kami cukup baik dan nyaman digunakan untuk kebutuhan pembuatan API menggunakan ExpressJS. Di arsitektur ini kita membuat proyeknya nodeJS nya dengan type 'commonJS' yah, (reminder) jadi saat modularisasi atau pemanggilan file atau librari kita gunakan const ... = require('nama file/librari') , dan untuk mengexport variabel/function/class kita gunakan module.exports = nama variable/function/class . Nah untuk memulai sobat bisa membuatnya secara manual, atau bisa menduplikat template yang sudah kami sediakan ya di repositori github algonacci . Namun, walau sobat bisa langsung menduplikat, usahakan tetap mengerti dengan arsitektur tersebut. Oleh karena itu, yuk simak penjelasan-penjelasan tentang arsitektur tersebut dibawah:","title":"Ringkasan Struktur Proyek"},{"location":"07_backend/#starting-point-serverjs","text":"Pertama, jika sobat memulainya secara manual, buatlah sebuah proyek Node.js baru dengan menggunakan command npm init , dengan starting pointnya di server.js , lalu isi dengan code seperti berikut: require(\"dotenv\").config(); const http = require(\"http\"); const app = require(\"./app\"); const PORT = process.env.PORT || 8000; const server = http.createServer(app); const start = async () => { try { server.listen(PORT, () => { console.log(`\ud83d\ude80 [SERVER] is running on port http://localhost:${PORT}`); }); } catch (error) { console.log(error); } }; start(); Pada kode tersebut sobat bisa lihat ada sebuat variabel yang di panggil dari sebuah file, yaitu app. Setelah kita membuat starting point ( server.js ), selanjutnya root folder kita buat lagi 1 file dengan nama app.js . Di file ini kita akan melakukan inisialisasi serta pemanggilan-pemanggilan router agar terlihat rapi. Dengan kode seperti berikut: const express = require(\"express\"); const morgan = require(\"morgan\"); const cors = require(\"cors\"); const app = express(); const swaggerUi = require('swagger-ui-express'); const YAML = require('yamljs') const apiDocs = YAML.load('./api-docs.yaml') //Middleware const { isAuthenticated } = require(\"./middleware/isAuthenticated\"); //Router const indexRouter = require(\"./routes/index/index.router\"); app.use(express.json()); app.use(morgan(\"dev\")); app.use(cors()); //Set API DOCS with Swagger app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(apiDocs)) //Regis Routes app.use(\"/\", isAuthenticated, indexRouter); module.exports = app;","title":"Starting Point (server.js)"},{"location":"07_backend/#routes","text":"Hal yang cukup berbeda dari kebanyakan arsitektur nodeJS yang lain dengan arsitektu yang kami buat yaitu, terletak pada folder routes/ ini. Pada folder ini, diisi kan dengan sub folder lagi sesuai kebutuhan/fitur yang ingin dikembangkan, lalu didalam sub folder ini berisikan file .router.js untuk mengatur jalurnya, .controller.js untuk membuat logika programnya, dan .test.js untuk membuat testing dari jalur/feat tersebut. Seperti sobat tahu, biasanya kebanyakan arsitektur nodeJS memisahkan ketiga hal tersebut (router/controller/testing) pada folder folder terpisah. Disini kami menggabungkannya karena memudahkan dalam pengerjaannya baik perorangan maupun team, dimana kita bisa mengerjakannya perfitur, sehingga lebih rapi dan terstruktur. Dalam pembuatana nama folder dan file nya di namakan dengan nama fitur yang kita buat/kembangkan, misal fitur 'index' maka sub folder dari routes/ adalah folder index/ yang berisi 3 file yaitu index.controller.js , index.router.js , dan index.test.js . Berikut adalah contoh kodenya:","title":"Routes/"},{"location":"07_backend/#indexcontrollerjs","text":"const { forExample } = require(\"../../helpers/forExample\"); const response = require(\"./../../helpers/response\") const helloIndex = (req, res) => { forExample(); response.res200(\"Success fetching the API!\", null, res) }; const helloPost = (req, res) => { const inputData = req.body; console.log(inputData); if (Object.keys(inputData).length !== 0) { response.res201(\"Success create data\", inputData, res) } else { response.res400(res) } }; const getData = async (req, res) => { try { let result = 'Testing '.repeat(10000) response.resCustom(200, \"Success fetching data\", result, res) } catch (error) { console.log(error.message) response.res500(res) } }; module.exports = { helloIndex, helloPost, getData };","title":"index.controller.js"},{"location":"07_backend/#indexrouterjs","text":"const express = require(\"express\"); const router = express.Router(); const compression = require(\"compression\"); //Middleware const cache = require('../../config/cache') const limit = require(\"./../../config/rateLimiter\") //Controller const index = require(\"./index.controller\"); //Routes router.route(\"/\").get(limit(10) ,index.helloIndex); //Set limiter 10 request/minutes router.route(\"/\").post(index.helloPost); router.route(\"/test\").get(compression(), cache('1 minutes'),index.getData); //Set compression and cache module.exports = router;","title":"index.router.js"},{"location":"07_backend/#indextestjs","text":"const { response } = require(\"express\"); const request = require(\"supertest\"); const app = require(\"../../app\"); const token = 'Ceritanya Token JWT'; describe(\"Test GET /\", () => { test(\"It should respond with 200 success\", async () => { const response = await request(app).get(\"/\") .set(\"Authorization\", `Bearer ${token}`) .expect(\"Content-Type\", /json/); expect(response.status).toBe(200); expect(response.body).toEqual({ status: { code: 200, message: \"Success fetching the API!\", }, data: null, }); }); }); ...dst","title":"index.test.js"},{"location":"07_backend/#middleware","text":"Folder middleware ini sama seperti arsitektur nodejs lainnya, disini kita menyimpan file-file yang berfungsi sebagai middleware atau file yang berisi fungsi untuk menengahi antara router dan controller. Biasanya berisikan pengecekan atau validasi seperti authentikasi/authorisasi, cache, rate limiter atau yang lainnya. Pada template yang kami buat kami menyediakan middleware yang umum digunakan yakni file isAuthenticate.js . Berikut contoh kodenya: const jwt = require(\"jsonwebtoken\") const response = require(\"./../helpers/response\") const isAuthenticated = (req, res, next) => { const { authorization } = req.headers; if (!authorization) { console.log(\"Token is not exist\") return response.res401(res); } const token = authorization.split(\" \")[1] || authorization; try { // // Uncomment to use Basic verify jwt token // const secret = process.env.JWT_KEY; // const jwtDecode = jwt.verify(token, secret); // //create user data to use in server, adjust with your data when you create token first time // const user = { // id: jwtDecode.id, // email: jwtDecode.email, // name: jwtDecode.name, // role: jwtDecode.role, // token, // }; // req.user = user; //set data to use in the next console.log(\"Anjay Authenticate\") next(); } catch (error) { console.log(error.message); return response.res401(res); } }; module.exports = { isAuthenticated };","title":"Middleware/"},{"location":"07_backend/#helpers","text":"Folder helpers/ lebih kurang sama dengan utils/ dimana didalam folder ini disimpan file-file fungsi yang akan sering digunakan. Seperti customisasi response, atau pengecekan data di database, atau yang lainnya. Untuk penamaan filenya disesuaikan dengan fungsi yang dibuat, berikut contoh isi kode dari file isExample.js dari template yang kami sediakan: const forExample = () => { console.log(\"Anjay pake helper\"); }; module.exports = { forExample }; note: untuk file isExample.js tersebut hanya contoh, sobat bisa ubah dan sesuakan penamaan dan isinya sesuai kebutuhan sobat, atau sobat bisa hapus jika tidak diperlukan.","title":"Helpers/"},{"location":"07_backend/#db-database","text":"Jika mendengar API pasti tidak jauh dari yang namanya database, umumnya jika kita membuat sebuah API biasanya pasti melakukan CRUD ke database baik SQL (MYSQL/POSTGREE/dll) atau bahkan NOSQL (MongoDB/Firestore/dll). Sehingga kita pasti perlu melakukan pembuatan koneksi ke database tersebut. Nah, disinilah kita gunakan folder db/ untuk menyimpan file yang mengandung kode untuk melakukan koneksi ke database. Berikut contoh kode file koneksi ke firestore (noSql): var admin = require(\"firebase-admin\"); admin.initializeApp({ credential: admin.credential.cert(JSON.parse(process.env.SERVICEACCOUNTKEY)) }); const db = admin.firestore() module.exports = db","title":"Db/ (Database)"},{"location":"07_backend/#models","text":"Jika kita melakukan koneksi atau aktifitas CRUD ke database maka kita juga tidak jauh dari yang namanya model. Apa itu model? model merupakan tempat kita membuat sebuah inisialisasi atau mendisign tabel/schema(SQL) di proyek kita. Biasanya saat menerapkan konsep model seperti ini kita menggunakan yang namanya ORM (Object Relation Mapping) misalnya seperti sequelize/prisma/typeorm/lainnya. Nah, di folder models/ ini lah tempat menyimpan file-file model tersebut.","title":"Models/"},{"location":"07_backend/#githubworkflows","text":"Terakhir ada folder .github/ yang berisi subfolder Workflows/ . Apakah ini? nah, disini merupakan folder tempat kita menyimpan alur kerja atau simplenya file automasi yang berisi kode langkah-langkah pengerjaan saat terjadi komunikasi ke github kita. Misalnya, seperti saat terjadi push/pull/lainnya ke repo github kita apa yang akan kita lakukan. Untuk template yang kami sediakan, kami sudah membuat file automasi untuk melakukan pengecekan semua kode-kode dari file .test.js yang kita buat, guna memastikan semua fitur yang kita buat dan sudah test berjalan dengan benar, baik di local maupun saat setelah di push ke github. Berikut contoh kode dari file automasi node.js.yaml yang kami sediakan di template: name: Express Docker Template Application on: push: branches: [\"main\"] pull_request: branches: [\"main\"] jobs: build: env: CI: true # MONGODB_URI: mongodb://localhost/nasa strategy: matrix: node-version: [14.x, 16.x, 18.x] # See supported Node.js release schedule at https://nodejs.org/en/about/releases/ # mongodb-version: [\"4.4\"] runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v3 with: node-version: ${{ matrix.node-version }} cache: \"npm\" - run: npm install - run: npm test note: Kode di atas melakukan pengecekan terhadap kode kita, di versi nodeJS 14.x, 16.x, dan 18.x","title":".github/Workflows"},{"location":"07_backend/#api-documentation","text":"Jika kita membuat sebuah proyek API, pastinya kita akan membuat sebuah dokumentasi dari API tersebut betul? Nah, untuk membuat sebuah dokumentasi API ada banyak tools yang tersedia, seperti Postman/Swagger/ReDoc/lainnya. Disini kita akan menggunakan swagger sebagai tools untuk membuat dokumentasinya, mengapa agar kita bisa langsung membuatnya di dalam proyek kita, tanpa harus menginstall aplikasi ketiga atau membuat di website toolsnya tersebut. Di root folder proyek kita, sobat bisa lihat di file app.js ada potongan kode seperti berikut: const swaggerUi = require('swagger-ui-express'); const YAML = require('yamljs') const apiDocs = YAML.load('./api-docs.yaml') ... //Set API DOCS with Swagger app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(apiDocs)) ... Yap, seperti potongan kode di atas, jika kita ingin menggunakan swagger langsung di proyek kita, kita perlu menginstall 2 librari yakni, swagger-ui-express dan yaml.js . Disini kita menggunakan swagger-ui-express yang membuatkan otomatis tampilan dokumentasi swaggernya dan yamljs untuk membaca kode dokumentasi yang kita buat menggunakan file .yaml seperti ./api-docs.yaml yang kami siapkan di template. Disini kita harus membuat terlebih dahulu dokumentasinya di file api-docs.yaml serperti contoh: openapi: '3.0.2' info: title: API Documentation description: Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML. version: '1.0.0' servers: - url: \"http://localhost:8080\" description: Optional server description, e.g. Main (development) server components: securitySchemes: bearerAuth: type: http scheme: bearer bearerFormat: JWT security: - bearerAuth: [] paths: /: get: summary: Returns a list of users. description: Optional extended description in CommonMark or HTML. tags: - 'Index' security: - bearerAuth: [] responses: '200': description: Response success for index routes. content: application/json: schema: type: object properties: status: type: object properties: code: type: integer format: int64 example: 200 message: type: string example: \"Success fetching the API!\" data: type: string example: null '401': description: Unauthorized user. default: description: Unexpected error Kemudian kita daftarkan dan aktifkan seperti akhir potongan kode sebelumnya app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(apiDocs)) sobat bisa mengganti path untuk dokumentasinya pada parameter pertama, untuk template yang kami sediakan, kami gunakan /api-docs untuk melihat dokumentasi dari API-nya. Kembali ke Home","title":"API Documentation"},{"location":"08_mobile/","text":"Mobile Flutter (The first choice) Swift/Kotlin if requested Kembali ke Home","title":"Mobile"},{"location":"08_mobile/#mobile","text":"Flutter (The first choice) Swift/Kotlin if requested Kembali ke Home","title":"Mobile"},{"location":"09_qa_manual/","text":"QA Manual Kembali ke Home","title":"QA Manual"},{"location":"09_qa_manual/#qa-manual","text":"Kembali ke Home","title":"QA Manual"},{"location":"10_qa_automation/","text":"QA Automation Selenium Katalon Kembali ke Home","title":"QA Automation"},{"location":"10_qa_automation/#qa-automation","text":"Selenium Katalon Kembali ke Home","title":"QA Automation"},{"location":"11_database/","text":"Database MySQL PostgreSQL Firebase Firestore Kembali ke Home","title":"Database"},{"location":"11_database/#database","text":"MySQL PostgreSQL Firebase Firestore Kembali ke Home","title":"Database"},{"location":"12_deployment/","text":"Deployment Netlify Docker Cloud Run Cloud Functions App Engine Compute Instance Local VPS Kembali ke Home","title":"12 deployment"},{"location":"12_deployment/#deployment","text":"Netlify Docker Cloud Run Cloud Functions App Engine Compute Instance Local VPS Kembali ke Home","title":"Deployment"},{"location":"13_blockchain/","text":"Blockchain Solidity on Ethereum Rust on Solana Kembali ke Home","title":"Blockchain"},{"location":"13_blockchain/#blockchain","text":"Solidity on Ethereum Rust on Solana Kembali ke Home","title":"Blockchain"},{"location":"14_rnd/","text":"RnD Perplexity.ai Zotero Consensus AI Gdocs LaTeX Kembali ke Home","title":"14 rnd"},{"location":"14_rnd/#rnd","text":"Perplexity.ai Zotero Consensus AI Gdocs LaTeX Kembali ke Home","title":"RnD"},{"location":"15_ui_ux/","text":"UI/UX Design Figma Maze.io Whimsical Google Form Kembali ke Home","title":"15 ui ux"},{"location":"15_ui_ux/#uiux-design","text":"Figma Maze.io Whimsical Google Form Kembali ke Home","title":"UI/UX Design"},{"location":"16_graphic_design/","text":"Graphic Designs Adobe Illustrator Adobe Photoshop Kembali ke Home","title":"Graphic Designs"},{"location":"16_graphic_design/#graphic-designs","text":"Adobe Illustrator Adobe Photoshop Kembali ke Home","title":"Graphic Designs"},{"location":"17_project_management/","text":"Project Management Tools Figma Internal PRD Maker Kembali ke Home","title":"Project Management Tools"},{"location":"17_project_management/#project-management-tools","text":"Figma Internal PRD Maker Kembali ke Home","title":"Project Management Tools"},{"location":"18_seo_tools/","text":"SEO Tools Ahrefs Kembali ke Home","title":"SEO Tools"},{"location":"18_seo_tools/#seo-tools","text":"Ahrefs Kembali ke Home","title":"SEO Tools"}]}